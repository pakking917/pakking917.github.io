<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>* sans. (knockoff)</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: monospace;
    overflow: hidden;
  }
  canvas { display: block; image-rendering: pixelated; }
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<script>
// ============================================================
//  KNOCKOFF SANS FIGHT  —  main.js (single-file version)
//  Extra for Experts:
//   1. Web Audio API: procedural 8-bit sound synthesis (no files)
//   2. Gamepad API: controller support
//   3. localStorage: death counter that Sans comments on
//   4. windowResized: fully responsive at any window size
// ============================================================

// ── Audio Context (Web Audio API) ───────────────────────────
let audioCtx;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
function beep(freq, dur=0.06, vol=0.18, type='square', detune=0) {
  try {
    const ctx = getAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type = type; osc.frequency.value = freq; osc.detune.value = detune;
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
    osc.start(); osc.stop(ctx.currentTime + dur);
  } catch(e) {}
}
function playHurt()    { beep(180, 0.12, 0.3, 'sawtooth'); }
function playDodge()   { beep(440, 0.04, 0.1, 'square'); beep(520, 0.04, 0.1, 'square'); }
function playType()    { beep(220 + Math.random()*80, 0.04, 0.08, 'square'); }
function playBlaster() { beep(80, 0.4, 0.35, 'sawtooth'); beep(60, 0.6, 0.2, 'sawtooth', -200); }
function playWin()     { [523,659,784,1047].forEach((f,i)=>setTimeout(()=>beep(f,0.2,0.2,'square'),i*180)); }
function playDead()    { [300,200,150,100].forEach((f,i)=>setTimeout(()=>beep(f,0.3,0.3,'sawtooth'),i*200)); }
function playLevelUp() { [392,523,659,784].forEach((f,i)=>setTimeout(()=>beep(f,0.15,0.2,'square'),i*120)); }

// ── localStorage death counter ───────────────────────────────
function getDeaths() { return parseInt(localStorage.getItem('sansDeaths') || '0'); }
function addDeath()  { localStorage.setItem('sansDeaths', getDeaths() + 1); }

// ── Level Data ───────────────────────────────────────────────
const level1 = {
  label: "level 1",
  bgColor: [0,0,0],
  sansColor: [30,144,255],
  dialogues: [
    ["* hey.", "* you're new around here, huh?", "* well...", "* let me show you around."],
    ["* not bad.", "* you've got some moves.", "* but we're just getting started."]
  ],
  attacks: [
    {type:'bone_h', time:2000, pos:0.3, speed:1.5, w:60, damage:1},
    {type:'bone_h', time:2800, pos:0.6, speed:1.5, w:60, damage:1},
    {type:'bone_h', time:3600, pos:0.5, speed:2,   w:60, damage:1},
    {type:'bone_v', time:4800, pos:0.3, speed:1.5, h:60, damage:1},
    {type:'bone_v', time:5200, pos:0.6, speed:1.5, h:60, damage:1},
    {type:'bone_h', time:6000, pos:0.2, speed:2,   w:80, damage:1},
    {type:'bone_h', time:6000, pos:0.8, speed:2,   w:80, damage:1},
  ],
  duration: 8000
};

const level2 = {
  label: "level 2",
  bgColor: [0,0,10],
  sansColor: [20,120,220],
  dialogues: [
    ["* heh.", "* so you're still here.", "* guess i'll have to try a little harder."],
    ["* wow.", "* you're pretty determined.", "* ...or just stubborn."]
  ],
  attacks: [
    {type:'bone_h', time:1500, pos:0.25, speed:2.5, w:70, damage:1},
    {type:'bone_h', time:1500, pos:0.75, speed:2.5, w:70, damage:1},
    {type:'bone_v', time:2500, pos:0.25, speed:2,   h:70, damage:1},
    {type:'bone_v', time:2500, pos:0.75, speed:2,   h:70, damage:1},
    {type:'bone_h', time:3800, pos:0.5,  speed:3,   w:50, damage:1},
    {type:'bone_h', time:4200, pos:0.35, speed:3,   w:50, damage:1},
    {type:'bone_h', time:4600, pos:0.65, speed:3,   w:50, damage:1},
    {type:'blaster',time:6000, pos:0.5, damage:3},
    {type:'bone_h', time:7000, pos:0.4,  speed:3,   w:55, damage:1},
    {type:'bone_h', time:7000, pos:0.6,  speed:3,   w:55, damage:1},
  ],
  duration: 9500
};

const level3 = {
  label: "level 3",
  bgColor: [0,0,20],
  sansColor: [10,90,200],
  dialogues: [
    ["* ok.", "* i'll be real with you.", "* i've been holding back.", "* not anymore."],
    ["* heh heh heh.", "* you're actually pretty good.", "* this is getting fun."]
  ],
  attacks: [
    {type:'bone_h', time:1000, pos:0.2,  speed:3,   w:65, damage:1},
    {type:'bone_h', time:1000, pos:0.8,  speed:3,   w:65, damage:1},
    {type:'bone_v', time:1800, pos:0.2,  speed:2.5, h:65, damage:1},
    {type:'bone_v', time:1800, pos:0.5,  speed:2.5, h:65, damage:1},
    {type:'bone_v', time:1800, pos:0.8,  speed:2.5, h:65, damage:1},
    {type:'bone_h', time:3000, pos:0.3,  speed:3.5, w:55, damage:1},
    {type:'bone_h', time:3200, pos:0.5,  speed:3.5, w:55, damage:1},
    {type:'bone_h', time:3400, pos:0.7,  speed:3.5, w:55, damage:1},
    {type:'blaster',time:5000, pos:0.3, damage:3},
    {type:'blaster',time:5500, pos:0.7, damage:3},
    {type:'bone_h', time:7000, pos:0.25, speed:4,   w:50, damage:1},
    {type:'bone_h', time:7200, pos:0.5,  speed:4,   w:50, damage:1},
    {type:'bone_h', time:7400, pos:0.75, speed:4,   w:50, damage:1},
    {type:'bone_v', time:8500, pos:0.4,  speed:3,   h:50, damage:1},
    {type:'bone_v', time:8500, pos:0.6,  speed:3,   h:50, damage:1},
  ],
  duration: 11000
};

const level4 = {
  label: "level 4",
  bgColor: [5,0,20],
  sansColor: [0,60,180],
  dialogues: [
    ["* ...", "* you know what?", "* i'm a little impressed.", "* just a little.", "* don't let it go to your head."],
    ["* ok.", "* NOW i'm impressed.", "* but this is the part where i stop going easy."]
  ],
  attacks: [
    {type:'bone_h', time:800,  pos:0.15, speed:4,   w:55, damage:1},
    {type:'bone_h', time:800,  pos:0.85, speed:4,   w:55, damage:1},
    {type:'bone_v', time:1400, pos:0.15, speed:3.5, h:55, damage:1},
    {type:'bone_v', time:1400, pos:0.5,  speed:3.5, h:55, damage:1},
    {type:'bone_v', time:1400, pos:0.85, speed:3.5, h:55, damage:1},
    {type:'blaster',time:3000, pos:0.25, damage:3},
    {type:'blaster',time:3200, pos:0.75, damage:3},
    {type:'bone_h', time:4500, pos:0.3,  speed:4.5, w:45, damage:1},
    {type:'bone_h', time:4700, pos:0.5,  speed:4.5, w:45, damage:1},
    {type:'bone_h', time:4900, pos:0.7,  speed:4.5, w:45, damage:1},
    {type:'bone_v', time:6000, pos:0.2,  speed:4,   h:45, damage:1},
    {type:'bone_v', time:6000, pos:0.4,  speed:4,   h:45, damage:1},
    {type:'bone_v', time:6000, pos:0.6,  speed:4,   h:45, damage:1},
    {type:'bone_v', time:6000, pos:0.8,  speed:4,   h:45, damage:1},
    {type:'blaster',time:7500, pos:0.5, damage:3},
    {type:'bone_h', time:9000, pos:0.2,  speed:5,   w:40, damage:1},
    {type:'bone_h', time:9000, pos:0.4,  speed:5,   w:40, damage:1},
    {type:'bone_h', time:9000, pos:0.6,  speed:5,   w:40, damage:1},
    {type:'bone_h', time:9000, pos:0.8,  speed:5,   w:40, damage:1},
  ],
  duration: 13000
};

const level5 = {
  label: "level 5",
  bgColor: [10,0,30],
  sansColor: [0,30,160],
  dialogues: [
    ["* ...", "* you're really doing this, huh.", "* fine.", "* FINE.", "* let's end this."],
    ["* ...", "* heh.", "* not bad, kid.", "* not bad at all.", "* you've earned it."]
  ],
  attacks: [
    {type:'bone_h', time:600,  pos:0.1,  speed:5,   w:50, damage:2},
    {type:'bone_h', time:600,  pos:0.9,  speed:5,   w:50, damage:2},
    {type:'bone_v', time:1000, pos:0.1,  speed:4,   h:50, damage:1},
    {type:'bone_v', time:1000, pos:0.35, speed:4,   h:50, damage:1},
    {type:'bone_v', time:1000, pos:0.65, speed:4,   h:50, damage:1},
    {type:'bone_v', time:1000, pos:0.9,  speed:4,   h:50, damage:1},
    {type:'blaster',time:2500, pos:0.2, damage:4},
    {type:'blaster',time:2700, pos:0.8, damage:4},
    {type:'bone_h', time:4000, pos:0.2,  speed:5.5, w:45, damage:1},
    {type:'bone_h', time:4100, pos:0.4,  speed:5.5, w:45, damage:1},
    {type:'bone_h', time:4200, pos:0.6,  speed:5.5, w:45, damage:1},
    {type:'bone_h', time:4300, pos:0.8,  speed:5.5, w:45, damage:1},
    {type:'blaster',time:6000, pos:0.33, damage:4},
    {type:'blaster',time:6000, pos:0.67, damage:4},
    {type:'bone_v', time:7500, pos:0.1,  speed:5,   h:45, damage:2},
    {type:'bone_v', time:7500, pos:0.3,  speed:5,   h:45, damage:2},
    {type:'bone_v', time:7500, pos:0.5,  speed:5,   h:45, damage:2},
    {type:'bone_v', time:7500, pos:0.7,  speed:5,   h:45, damage:2},
    {type:'bone_v', time:7500, pos:0.9,  speed:5,   h:45, damage:2},
    {type:'bone_h', time:9000, pos:0.15, speed:6,   w:40, damage:2},
    {type:'bone_h', time:9100, pos:0.35, speed:6,   w:40, damage:2},
    {type:'bone_h', time:9200, pos:0.5,  speed:6,   w:40, damage:2},
    {type:'bone_h', time:9300, pos:0.65, speed:6,   w:40, damage:2},
    {type:'bone_h', time:9400, pos:0.85, speed:6,   w:40, damage:2},
    {type:'blaster',time:11000,pos:0.5, damage:5},
    {type:'bone_h', time:12000,pos:0.25, speed:6,   w:38, damage:2},
    {type:'bone_h', time:12000,pos:0.5,  speed:6,   w:38, damage:2},
    {type:'bone_h', time:12000,pos:0.75, speed:6,   w:38, damage:2},
    {type:'bone_v', time:12000,pos:0.25, speed:5,   h:38, damage:2},
    {type:'bone_v', time:12000,pos:0.75, speed:5,   h:38, damage:2},
  ],
  duration: 15000
};

const LEVELS = [level1, level2, level3, level4, level5];

// ── Game State ───────────────────────────────────────────────
let gameState = 'title';  // title | intro | battle | levelclear | win | gameover
let currentLevel = 0;
let levelTimer = 0;
let levelStartTime = 0;

// Player
let heartX, heartY;
let heartVX = 0, heartVY = 0;
let playerHP = 20;
let playerMaxHP = 20;
let iframes = 0;
let HEART_SPEED;

// Battle box
let box = {};

// Attacks
let activeAttacks = [];
let attackQueue = [];

// Dialogue
let dialogueLines = [];
let dialogueIndex = 0;
let charIndex = 0;
let typeTimer = 0;
const TYPE_SPEED = 2; // frames per char
let dialogueDone = false;
let dialoguePhase = 0; // 0=before battle, 1=after battle

// Sans animation
let sansPhase = 'idle'; // idle|talking|attacking|hurt
let sansBob = 0;
let sansLean = 0;
let sansMouthOpen = false;
let sansX, sansY, spiteScale, baseSize;

// Screen shake
let shakeX = 0, shakeY = 0, shakeMag = 0;

// Particles
let particles = [];

// Flash
let flashAlpha = 0;
let flashColor = [255,255,255];

// Blaster charge particles
let blasterFlash = 0;

// Fonts loaded flag
let fontReady = false;

// Title/gameover screen
let titlePulse = 0;

// ── p5 setup ─────────────────────────────────────────────────
function setup() {
  calcSizes();
  createCanvas(baseSize * 4, baseSize * 3);
  textFont('monospace');
  resetPlayer();
}

function calcSizes() {
  baseSize = Math.floor(Math.min(windowWidth / 4, windowHeight / 3, 160));
  HEART_SPEED = baseSize * 0.03;
}

function windowResized() {
  calcSizes();
  resizeCanvas(baseSize * 4, baseSize * 3);
  spiteScale = baseSize / 100 / 2.2;
  sansX = width / 2;
  sansY = height / 4;
  box = makeBattleBox();
  if (gameState !== 'title') {
    heartX = constrain(heartX, box.x + 8, box.x + box.w - 8);
    heartY = constrain(heartY, box.y + 8, box.y + box.h - 8);
  }
}

function makeBattleBox() {
  return {
    x: width * 0.1,
    y: height * 0.5,
    w: width * 0.8,
    h: height * 0.38
  };
}

function resetPlayer() {
  spiteScale = baseSize / 100 / 2.2;
  sansX = width / 2;
  sansY = height / 4;
  box = makeBattleBox();
  heartX = box.x + box.w / 2;
  heartY = box.y + box.h / 2;
  playerHP = playerMaxHP;
  iframes = 0;
  activeAttacks = [];
  attackQueue = [];
  particles = [];
  shakeX = shakeY = 0; shakeMag = 0;
  flashAlpha = 0;
}

// ── DRAW ─────────────────────────────────────────────────────
function draw() {
  titlePulse += 0.04;

  if (gameState === 'title')     drawTitle();
  else if (gameState === 'intro')     drawDialogue(false);
  else if (gameState === 'battle')    drawBattle();
  else if (gameState === 'levelclear') drawDialogue(true);
  else if (gameState === 'win')       drawWinScreen();
  else if (gameState === 'gameover')  drawGameOver();
}

// ── TITLE ─────────────────────────────────────────────────────
function drawTitle() {
  background(0);
  let d = getDeaths();

  // Scanline bg
  for (let y = 0; y < height; y += 4) {
    stroke(10,10,10); strokeWeight(1);
    line(0, y, width, y);
  }

  drawSans(sansX, sansY + sin(titlePulse)*4, spiteScale, [30,144,255], 'idle', sin(titlePulse));

  noStroke();
  fill(255);
  textAlign(CENTER);

  // Title
  let tSize = baseSize * 0.22;
  textSize(tSize);
  text('* SANS.', width/2, height * 0.08);
  textSize(tSize * 0.45);
  fill(180);
  text('(knockoff)', width/2, height * 0.08 + tSize * 0.7);

  // Death counter from localStorage
  if (d > 0) {
    fill(200,120,120);
    textSize(baseSize * 0.09);
    let msg = d === 1 ? `* you died once before.` :
              d < 5  ? `* you've died ${d} times.` :
              d < 10 ? `* ${d} deaths. getting better?` :
              `* ${d} deaths. heh. determination.`;
    text(msg, width/2, height * 0.88);
  }

  fill(abs(sin(titlePulse)) * 200 + 55);
  textSize(baseSize * 0.1);
  text('press ENTER or Z to start', width/2, height * 0.93);

  textAlign(LEFT);
}

// ── DIALOGUE ─────────────────────────────────────────────────
function startDialogue(phase) {
  let lvl = LEVELS[currentLevel];
  dialogueLines = lvl.dialogues[phase] || [];
  dialogueIndex = 0;
  charIndex = 0;
  typeTimer = 0;
  dialogueDone = false;
  dialoguePhase = phase;
}

function drawDialogue(isPost) {
  let lvl = LEVELS[currentLevel];
  background(lvl.bgColor[0], lvl.bgColor[1], lvl.bgColor[2]);

  sansPhase = 'talking';
  drawSans(sansX, sansY + sin(frameCount*0.05)*3, spiteScale, lvl.sansColor, 'talking', 0);

  // Typewriter
  typeTimer++;
  if (typeTimer >= TYPE_SPEED && charIndex < (dialogueLines[dialogueIndex]||'').length) {
    charIndex++;
    typeTimer = 0;
    if (frameCount % 2 === 0) playType();
  }

  // Draw dialogue box
  drawDialogueBox(dialogueLines[dialogueIndex] ? dialogueLines[dialogueIndex].slice(0, charIndex) : '');

  if (charIndex >= (dialogueLines[dialogueIndex]||'').length) {
    dialogueDone = true;
    // blinking prompt
    if (sin(frameCount * 0.15) > 0) {
      fill(255); noStroke();
      textSize(baseSize * 0.1);
      textAlign(RIGHT);
      text('▼', width * 0.88, height * 0.88);
      textAlign(LEFT);
    }
  }
}

function drawDialogueBox(txt) {
  let bx = width * 0.05, by = height * 0.72;
  let bw = width * 0.9, bh = height * 0.2;
  stroke(255); strokeWeight(max(2, baseSize*0.02)); fill(0);
  rect(bx, by, bw, bh);
  fill(255); noStroke();
  textSize(max(10, baseSize * 0.1));
  textAlign(LEFT);
  text(txt, bx + bw*0.03, by + bh*0.38, bw*0.94, bh*0.8);
}

// ── BATTLE ────────────────────────────────────────────────────
function drawBattle() {
  let lvl = LEVELS[currentLevel];
  let elapsed = millis() - levelStartTime;

  // Spawn queued attacks
  while (attackQueue.length > 0 && attackQueue[0].time <= elapsed) {
    spawnAttack(attackQueue.shift());
  }

  // Shake
  if (shakeMag > 0.5) {
    shakeX = random(-shakeMag, shakeMag);
    shakeY = random(-shakeMag, shakeMag);
    shakeMag *= 0.85;
  } else { shakeX = shakeY = 0; }

  translate(shakeX, shakeY);

  background(lvl.bgColor[0], lvl.bgColor[1], lvl.bgColor[2]);

  // Update sans phase
  if (activeAttacks.length > 0) {
    sansPhase = 'attacking';
    sansLean = lerp(sansLean, 8, 0.08);
  } else {
    sansPhase = 'idle';
    sansLean = lerp(sansLean, 0, 0.1);
  }

  let bobAmt = sansPhase === 'attacking' ? sin(frameCount*0.15)*5 : sin(frameCount*0.05)*3;
  drawSans(sansX, sansY + bobAmt, spiteScale, lvl.sansColor, sansPhase, sansLean/8);

  // Battle box
  stroke(255); strokeWeight(max(2, baseSize*0.025)); fill(0);
  rect(box.x, box.y, box.w, box.h);

  // Gamepad input
  pollGamepad();

  // Heart movement
  updateHeart();

  // Update + draw attacks
  for (let i = activeAttacks.length-1; i >= 0; i--) {
    activeAttacks[i].update();
    activeAttacks[i].draw();
    if (iframes <= 0 && activeAttacks[i].hits(heartX, heartY)) {
      let dmg = activeAttacks[i].damage || 1;
      playerHP = max(0, playerHP - dmg);
      iframes = 45;
      shakeMag = dmg * 4;
      flashAlpha = 200; flashColor = [255,0,0];
      playHurt();
      spawnHurtParticles(heartX, heartY);
      if (playerHP <= 0) { triggerGameOver(); return; }
    }
    if (activeAttacks[i].dead) activeAttacks.splice(i,1);
  }

  // Iframes
  if (iframes > 0) iframes--;

  // Draw heart (flicker during iframes)
  if (iframes <= 0 || frameCount % 4 < 2) {
    drawHeart(heartX, heartY, spiteScale);
  }

  // Particles
  updateParticles();

  // HUD
  drawHUD();

  // Flash
  if (flashAlpha > 0) {
    noStroke(); fill(flashColor[0], flashColor[1], flashColor[2], flashAlpha);
    rect(0,0,width,height);
    flashAlpha = max(0, flashAlpha - 12);
  }

  // Level end
  if (elapsed >= lvl.duration && activeAttacks.length === 0) {
    playLevelUp();
    flashAlpha = 180; flashColor = [255,255,255];
    gameState = 'levelclear';
    startDialogue(1);
  }
}

function updateHeart() {
  heartVX = 0; heartVY = 0;
  if (keyIsDown(LEFT_ARROW)  || keyIsDown(65)) heartVX = -HEART_SPEED;
  if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) heartVX =  HEART_SPEED;
  if (keyIsDown(UP_ARROW)    || keyIsDown(87)) heartVY = -HEART_SPEED;
  if (keyIsDown(DOWN_ARROW)  || keyIsDown(83)) heartVY =  HEART_SPEED;
  // Normalize diagonal
  if (heartVX !== 0 && heartVY !== 0) { heartVX *= 0.707; heartVY *= 0.707; }
  heartX = constrain(heartX + heartVX, box.x + 6, box.x + box.w - 6);
  heartY = constrain(heartY + heartVY, box.y + 6, box.y + box.h - 6);
}


// ── SPAWN ATTACKS ─────────────────────────────────────────────
function spawnAttack(data) {
  if (data.type === 'bone_h') {
    activeAttacks.push(new BoneH(data));
  } else if (data.type === 'bone_v') {
    activeAttacks.push(new BoneV(data));
  } else if (data.type === 'blaster') {
    activeAttacks.push(new Blaster(data));
    playBlaster();
    shakeMag = 5;
    flashAlpha = 60; flashColor = [100,200,255];
  }
}

// ── BONE HORIZONTAL ──────────────────────────────────────────
class BoneH {
  constructor(data) {
    this.y = lerp(box.y + 10, box.y + box.h - 10, data.pos);
    this.x = box.x - (data.w || 60) - 10;
    this.w = data.w || 60;
    this.h = max(10, baseSize * 0.09);
    this.speed = data.speed * (baseSize / 120);
    this.damage = data.damage || 1;
    this.dead = false;
  }
  update() {
    this.x += this.speed;
    if (this.x > box.x + box.w + 20) this.dead = true;
  }
  draw() {
    push();
    fill(255); stroke(0); strokeWeight(max(1.5, baseSize*0.015));
    // End caps
    let r = this.h / 2 + 2;
    ellipse(this.x + this.h/2, this.y, r*2, r*2);
    ellipse(this.x + this.w - this.h/2, this.y, r*2, r*2);
    // Shaft
    noStroke(); fill(255);
    rect(this.x + this.h/2, this.y - this.h/2, this.w - this.h, this.h);
    pop();
  }
  hits(hx, hy) {
    return hx > this.x && hx < this.x + this.w &&
           hy > this.y - this.h/2 - 3 && hy < this.y + this.h/2 + 3;
  }
}

// ── BONE VERTICAL ────────────────────────────────────────────
class BoneV {
  constructor(data) {
    this.x = lerp(box.x + 10, box.x + box.w - 10, data.pos);
    this.y = box.y - (data.h || 60) - 10;
    this.h = data.h || 60;
    this.w = max(10, baseSize * 0.09);
    this.speed = data.speed * (baseSize / 120);
    this.damage = data.damage || 1;
    this.dead = false;
  }
  update() {
    this.y += this.speed;
    if (this.y > box.y + box.h + 20) this.dead = true;
  }
  draw() {
    push();
    fill(255); stroke(0); strokeWeight(max(1.5, baseSize*0.015));
    let r = this.w / 2 + 2;
    ellipse(this.x, this.y + this.w/2, r*2, r*2);
    ellipse(this.x, this.y + this.h - this.w/2, r*2, r*2);
    noStroke(); fill(255);
    rect(this.x - this.w/2, this.y + this.w/2, this.w, this.h - this.w);
    pop();
  }
  hits(hx, hy) {
    return hx > this.x - this.w/2 - 3 && hx < this.x + this.w/2 + 3 &&
           hy > this.y && hy < this.y + this.h;
  }
}

// ── BLASTER ──────────────────────────────────────────────────
class Blaster {
  constructor(data) {
    this.x = lerp(box.x + 20, box.x + box.w - 20, data.pos);
    this.y = box.y - baseSize * 0.3;
    this.damage = data.damage || 3;
    this.dead = false;
    this.phase = 'charge'; // charge → fire → fade
    this.timer = 0;
    this.chargeDur = 60;
    this.fireDur   = 30;
    this.fadeDur   = 20;
    this.beamW = max(14, baseSize * 0.12);
    this.beamH = box.h + baseSize * 0.4;
    this.alpha = 0;
    this.fireY = box.y - baseSize * 0.05;
  }
  update() {
    this.timer++;
    if (this.phase === 'charge') {
      this.alpha = map(this.timer, 0, this.chargeDur, 0, 255);
      if (this.timer >= this.chargeDur) { this.phase = 'fire'; this.timer = 0; }
    } else if (this.phase === 'fire') {
      this.alpha = 255;
      if (this.timer >= this.fireDur) { this.phase = 'fade'; this.timer = 0; }
    } else if (this.phase === 'fade') {
      this.alpha = map(this.timer, 0, this.fadeDur, 255, 0);
      if (this.timer >= this.fadeDur) this.dead = true;
    }
  }
  draw() {
    push();
    if (this.phase === 'charge') {
      // Skull head charging
      let pulse = sin(this.timer * 0.3) * 0.2 + 1;
      this._drawSkull(this.x, this.y, pulse, this.alpha);
      // charging particles
      if (random() < 0.5) {
        particles.push({
          x: this.x + random(-20,20), y: this.y + random(-10,10),
          vx: random(-1,1), vy: random(1,3),
          life: 20, maxLife:20, r:100, g:200, b:255, size: random(3,7)
        });
      }
    } else {
      // Skull + beam
      this._drawSkull(this.x, this.y, 1, this.alpha);
      // Beam
      noStroke();
      let bAlpha = this.alpha;
      // Glow
      fill(100, 220, 255, bAlpha * 0.3);
      rect(this.x - this.beamW*1.8, this.fireY, this.beamW*3.6, this.beamH);
      fill(200, 240, 255, bAlpha * 0.6);
      rect(this.x - this.beamW, this.fireY, this.beamW*2, this.beamH);
      fill(255, 255, 255, bAlpha);
      rect(this.x - this.beamW*0.4, this.fireY, this.beamW*0.8, this.beamH);
    }
    pop();
  }
  _drawSkull(x, y, sc, al) {
    push();
    translate(x, y);
    scale(sc * spiteScale * 0.7);
    let a = al;
    stroke(0, a); strokeWeight(2); fill(255, a);
    ellipse(0, 0, 90, 70);
    // eyes
    fill(0, a); ellipse(-20,-5,18,22); ellipse(20,-5,18,22);
    fill(100,220,255,a); ellipse(-20,-5,12,16); ellipse(20,-5,12,16);
    fill(0,a); ellipse(-20,-5,4,4); ellipse(20,-5,4,4);
    // teeth
    fill(255,a); noStroke();
    for (let i=-20; i<=20; i+=10) rect(i-4,15,8,10,2);
    pop();
  }
  hits(hx, hy) {
    if (this.phase !== 'fire') return false;
    return hx > this.x - this.beamW && hx < this.x + this.beamW &&
           hy > this.fireY && hy < this.fireY + this.beamH;
  }
}

// ── HUD ───────────────────────────────────────────────────────
function drawHUD() {
  let bx = box.x, bby = box.y + box.h;
  let bw = box.w;
  let pad = baseSize * 0.04;

  // HP label
  fill(255); noStroke();
  textSize(max(9, baseSize * 0.09));
  textAlign(LEFT);
  text('HP', bx, bby + pad + baseSize * 0.11);

  // HP bar background
  let barX = bx + baseSize * 0.25;
  let barY = bby + pad;
  let barW = bw - baseSize * 0.28;
  let barH = max(10, baseSize * 0.12);
  fill(60); noStroke();
  rect(barX, barY, barW, barH);

  // HP bar fill
  let pct = playerHP / playerMaxHP;
  let hpColor = pct > 0.5 ? color(255,220,0) : pct > 0.25 ? color(255,140,0) : color(255,50,50);
  fill(hpColor);
  rect(barX, barY, barW * pct, barH);
  stroke(255); strokeWeight(max(1.5, baseSize*0.015)); noFill();
  rect(barX, barY, barW, barH);

  // HP numbers
  fill(255); noStroke();
  textSize(max(8, baseSize * 0.085));
  textAlign(RIGHT);
  text(`${playerHP} / ${playerMaxHP}`, barX + barW, barY - baseSize*0.01);

  // Level indicator
  textAlign(CENTER);
  textSize(max(8, baseSize * 0.08));
  fill(150);
  text(LEVELS[currentLevel].label, width/2, box.y - pad * 0.5);

  textAlign(LEFT);
}

// ── PARTICLES ────────────────────────────────────────────────
function spawnHurtParticles(x, y) {
  for (let i = 0; i < 12; i++) {
    let a = random(TWO_PI);
    particles.push({
      x, y,
      vx: cos(a) * random(1,4),
      vy: sin(a) * random(1,4),
      life: 25, maxLife: 25,
      r:255, g:30, b:30, size: random(3,7)
    });
  }
}

function updateParticles() {
  for (let i = particles.length-1; i >= 0; i--) {
    let p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--;
    let al = map(p.life, 0, p.maxLife, 0, 255);
    noStroke(); fill(p.r, p.g, p.b, al);
    rect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    if (p.life <= 0) particles.splice(i,1);
  }
}

// ── WIN / GAME OVER ───────────────────────────────────────────
function drawWinScreen() {
  background(0);
  drawSans(sansX, sansY + sin(titlePulse)*3, spiteScale, [30,144,255], 'idle', 0);
  fill(255); noStroke(); textAlign(CENTER);
  textSize(baseSize * 0.25);
  text('* you win.', width/2, height*0.06);
  textSize(baseSize * 0.1);
  fill(200);
  text('* heh. not bad, kid.', width/2, height*0.17);
  text(`* deaths: ${getDeaths()}`, width/2, height*0.24);
  fill(abs(sin(titlePulse))*200+55);
  textSize(baseSize*0.1);
  text('press ENTER to play again', width/2, height*0.93);
  textAlign(LEFT);
}

function drawGameOver() {
  background(0);
  fill(255,50,50); noStroke(); textAlign(CENTER);
  textSize(baseSize * 0.28);

  // Flicker effect
  if (sin(titlePulse * 3) > -0.3) {
    text('GAME OVER', width/2, height*0.45);
  }

  fill(180);
  textSize(baseSize * 0.1);
  text(`HP ran out on ${LEVELS[currentLevel].label}`, width/2, height*0.58);
  text(`total deaths: ${getDeaths()}`, width/2, height*0.66);

  fill(abs(sin(titlePulse))*200+55);
  textSize(baseSize*0.1);
  text('press ENTER to try again', width/2, height*0.82);
  textAlign(LEFT);
}

function triggerGameOver() {
  addDeath();
  playDead();
  gameState = 'gameover';
}

// ── SANS ──────────────────────────────────────────────────────
function drawSans(x, y, size, col, phase, lean) {
  push();
  translate(x, y);
  scale(size);
  rotate(lean * 0.08);

  stroke(0); strokeWeight(2); rectMode(CENTER);

  // Body
  fill(col[0], col[1], col[2]);
  rect(0, 40, 80, 60, 10);

  // Collar
  fill(255);
  ellipse(0, 12, 72, 26);

  // Head
  fill(255);
  ellipse(0, -10, 100, 85);

  // Eyes — glow during attack phase
  let eyeColor = phase === 'attacking' ? [132,255,242] : [132,255,242];
  fill(0);
  ellipse(-22, -15, 20, 25);
  ellipse( 22, -15, 20, 25);
  fill(eyeColor[0], eyeColor[1], eyeColor[2]);
  ellipse(-22, -15, 15, 20);
  ellipse( 22, -15, 15, 20);
  fill(0);
  ellipse(-22, -15, 5, 5);
  ellipse( 22, -15, 5, 5);

  // Nose
  fill(0);
  triangle(0, -2, -5, 9, 5, 9);

  // Mouth — open if talking
  noFill(); stroke(0); strokeWeight(2);
  if (phase === 'talking' && sin(frameCount*0.2) > 0) {
    arc(0, 15, 55, 35, 0, PI);
    for (let i = -20; i <= 20; i += 10) line(i, 15, i, 30);
    line(-27, 15, 27, 15);
  } else {
    arc(0, 15, 55, 28, 0, PI);
    for (let i = -20; i <= 20; i += 10) line(i, 15, i, 27);
    line(-27, 15, 27, 15);
  }

  // Attack glow eyes
  if (phase === 'attacking') {
    noStroke(); fill(132,255,242, 80);
    ellipse(-22,-15,28,34);
    ellipse(22,-15,28,34);
  }

  pop();
}

// ── HEART ─────────────────────────────────────────────────────
function drawHeart(x, y, size) {
  push();
  translate(x, y);
  scale(size * 1.2);
  noStroke(); fill(255,0,0);
  let p = 3;
  rect(-2*p, -3*p, 2*p, p);
  rect( 1*p, -3*p, 2*p, p);
  rect(-3*p, -2*p, 7*p, 3*p);
  rect(-2*p,  1*p, 5*p, p);
  rect(-1*p,  2*p, 3*p, p);
  rect(    0,  3*p, p,   p);
  pop();
}

// ── INPUT ─────────────────────────────────────────────────────
function keyPressed() {
  if (key === 'Enter' || key === 'z' || key === 'Z' || keyCode === 90) {
    handleAdvance();
  }
}

function mousePressed() {
  handleAdvance();
}

function handleAdvance() {
  if (gameState === 'title') {
    gameState = 'intro';
    currentLevel = 0;
    playerHP = playerMaxHP;
    startDialogue(0);

  } else if (gameState === 'intro') {
    if (!dialogueDone) {
      // skip to end of current line
      charIndex = (dialogueLines[dialogueIndex]||'').length;
    } else {
      dialogueIndex++;
      if (dialogueIndex >= dialogueLines.length) {
        // Start battle
        box = makeBattleBox();
        heartX = box.x + box.w/2;
        heartY = box.y + box.h/2;
        activeAttacks = [];
        attackQueue = [...LEVELS[currentLevel].attacks];
        levelStartTime = millis();
        particles = [];
        gameState = 'battle';
        sansPhase = 'idle';
      } else {
        charIndex = 0; typeTimer = 0; dialogueDone = false;
      }
    }

  } else if (gameState === 'levelclear') {
    if (!dialogueDone) {
      charIndex = (dialogueLines[dialogueIndex]||'').length;
    } else {
      dialogueIndex++;
      if (dialogueIndex >= dialogueLines.length) {
        currentLevel++;
        if (currentLevel >= LEVELS.length) {
          playWin();
          gameState = 'win';
        } else {
          // Heal a bit between levels
          playerHP = min(playerMaxHP, playerHP + 4);
          gameState = 'intro';
          startDialogue(0);
        }
      } else {
        charIndex = 0; typeTimer = 0; dialogueDone = false;
      }
    }

  } else if (gameState === 'win' || gameState === 'gameover') {
    resetPlayer();
    currentLevel = 0;
    playerHP = playerMaxHP;
    gameState = 'title';
  }
}
</script>
</body>
</html>
